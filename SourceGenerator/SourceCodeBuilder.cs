using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator;

internal class SourceCodeBuilder(){

    internal string Build(
        IList<string> output,
        IMethodSymbol mainMethod)
    {
        string source = $@"// <auto-generated/>
// {DateTime.Now:O}
using System;

namespace {mainMethod.ContainingNamespace.ToDisplayString()}
{{
    public static partial class {mainMethod.ContainingType.Name}
    {{
        static partial void HelloFrom(string name) =>
            Console.WriteLine($""Generator says: Hi from '{{name}}!!!'"");
    }}
}}
";
        return source;
    }

    internal string Build(
        Compilation compilation,
        string nameSpace,
        IList<string> output,
        IImmutableList<(TypeCollector.IsOfType isOfType, TypeDeclarationSyntax type, IEnumerable<AttributeSyntax> attribs)> types)
    {
//        var model = compilation.GetSemanticModel(compilation.SyntaxTrees.Skip(0).First());
        ClassDeclarationSyntax CreateClass(string name) =>
            SyntaxFactory.ClassDeclaration(SyntaxFactory.Identifier(name))
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword));

        var ns = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(nameSpace)).NormalizeWhitespace();

        var autoComment = SyntaxFactory.Comment("// <auto-generated/>");
        var nsComments = new List<SyntaxTrivia>();

        foreach (var type in types)
        {
            var namesp = GetNamespace(type.type);


            nsComments.Add(SyntaxFactory.Comment($"// Namespace for method:{namesp}"));

            // var className = type.type.GetDeclaredSymbol(compilation)?.ToDisplayString();
            var className = type.type.GetDeclaredSymbol(compilation)?.Name.ToString();
            ns = ns.AddMembers(CreateClass(className));
        }

        string source = $@"{autoComment} 
// {DateTime.Now:O}

// classes:
// {output.StringJoinNL()}
// namspace:
// {nsComments.Select(c => c.ToString()).StringJoinNL()}

{ns.NormalizeWhitespace()}
";

        return source;
    }

    /// <summary> Copied with pride from https://andrewlock.net/creating-a-source-generator-part-5-finding-a-type-declarations-namespace-and-type-hierarchy/
    // determine the namespace the class/enum/struct is declared in, if any
    static string GetNamespace(BaseTypeDeclarationSyntax syntax)
    {
        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        string nameSpace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        SyntaxNode? potentialNamespaceParent = syntax.Parent;

        // Keep moving "out" of nested classes etc until we get to a namespace
        // or until we run out of parents
        while (potentialNamespaceParent != null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax
               && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            nameSpace = namespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                namespaceParent = parent;
            }
        }

        // return the final namespace
        return nameSpace;
    }
}