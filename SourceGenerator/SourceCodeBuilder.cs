using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator;

internal class SourceCodeBuilder(){

    internal IEnumerable<(string source, string namespaceName, string classOrRecordName)> Build(
        Compilation compilation,
        IImmutableList<(TypeCollector.IsOfType isOfType, TypeDeclarationSyntax type, IEnumerable<AttributeSyntax>
            attribs)> types)
    {
        foreach (var type in types)
        {
            yield return Build(compilation, type.isOfType, type.type, type.attribs);
        }
    }

    private (string source, string namespaceName, string classOrRecordName) Build(
        Compilation compilation,
        TypeCollector.IsOfType isOfType,
        TypeDeclarationSyntax type,
        IEnumerable<AttributeSyntax> attribs)
    {
        // Which model is this?
        // var model = compilation.GetSemanticModel(compilation.SyntaxTrees.Skip(0).First());

        var namespaceName = GetNamespaceName(type);
        var ns = CreateNamespace(namespaceName);

        var classRecordName = type.GetDeclaredSymbol(compilation)?.Name
            ?? throw new Exception("The name of the class or record was unknown. It should not come here.");

        var members = type.Members.Select(m => m as PropertyDeclarationSyntax).Where(m => m is not null);

        if (isOfType == TypeCollector.IsOfType.IsClass)
        {
            var recordInfo = RecordOrClassInfo.Create(classRecordName,
                members.Select(PropertyInfo.Create));

            ns = ns.AddMembers(CreateClass(recordInfo));
        }

        if (isOfType == TypeCollector.IsOfType.IsRecord)
        {
            var recordInfo = RecordOrClassInfo.Create(classRecordName,
                members.Select(PropertyInfo.Create));

            ns = ns.AddMembers(CreateRecord(recordInfo));
        }

        string source = $@"// <auto-generated 
// created=""{DateTime.Now:O}""
// subject=""{namespaceName}.{classRecordName}""
// />

{ns.NormalizeWhitespace()}
";

        return (source, namespaceName, classRecordName);
    }

    private static ArgumentSyntax CreateArgument(PropertyInfo propertyInfo)
    {
        return SyntaxFactory.Argument(SyntaxFactory.IdentifierName(propertyInfo.Name));
    }

    private static ArgumentListSyntax? CreateArgumentList(IEnumerable<PropertyInfo> propertyInfos)
    {
        var arguments = SyntaxFactory.ArgumentList();
        foreach (var propertyInfo in propertyInfos)
        {
            arguments = arguments.AddArguments(CreateArgument(propertyInfo));
        }
        return arguments;
    }

    private ClassDeclarationSyntax CreateClass(RecordOrClassInfo recordOrClassInfo)
    {
        var constructorInfo = ConstructorInfo.Create(recordOrClassInfo.Name, recordOrClassInfo.Properties);
        var constructor = CreateConstructor(constructorInfo);

        var factoryMethod = CreateFactoryMethod(constructorInfo);

        return SyntaxFactory.ClassDeclaration(SyntaxFactory.Identifier(recordOrClassInfo.Name))
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword))
            .AddMembers(constructor, factoryMethod);
    }

    /// <summary>Create a constructor taking a list of parameters
    /// and updating properties of the same name.
    /// </summary>
    /// <param name="constructorInfo"></param>
    /// <returns></returns>
    private static ConstructorDeclarationSyntax CreateConstructor(ConstructorInfo constructorInfo)
    {
        var modifiers = SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword));

        var parameters = CreateParameterList(constructorInfo.Properties);

        var body = SyntaxFactory.Block(constructorInfo.Properties.Select(propertyInfo =>
            // Assignment. E.g.: this.MyProperty = MyProperty;
            SyntaxFactory.ExpressionStatement(SyntaxFactory.AssignmentExpression(
                SyntaxKind.SimpleAssignmentExpression,
                SyntaxFactory.IdentifierName("this." + propertyInfo.Name),
                SyntaxFactory.IdentifierName(propertyInfo.Name)))
        ));

        var ret = SyntaxFactory.ConstructorDeclaration(SyntaxFactory.Identifier(constructorInfo.Name))
            .WithModifiers(modifiers)
            .WithParameterList(parameters)
            .WithBody(body);
        return ret;
    }

    private static MethodDeclarationSyntax CreateFactoryMethod(ConstructorInfo constructorInfo)
    {
        var modifiers = SyntaxFactory.TokenList(
            SyntaxFactory.Token(SyntaxKind.PublicKeyword),
            SyntaxFactory.Token(SyntaxKind.StaticKeyword));

        var parameters = CreateParameterList(constructorInfo.Properties);
        var arguments = CreateArgumentList(constructorInfo.Properties);

        var body = SyntaxFactory.Block(
            // Return. E.g.: return new MyDto(a,b,c);
            SyntaxFactory.ReturnStatement(
                SyntaxFactory.ObjectCreationExpression(
                    SyntaxFactory.ParseTypeName(constructorInfo.Name)
                ).WithArgumentList(arguments)
            ));

        var ret = SyntaxFactory.MethodDeclaration(
                SyntaxFactory.ParseTypeName(constructorInfo.Name),
                "Create")
            .WithModifiers(modifiers)
            .WithParameterList(parameters)
            .WithBody(body);
        return ret;
    }

    private static NamespaceDeclarationSyntax CreateNamespace(string nameSpaceName)
    {
        return SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(nameSpaceName)).NormalizeWhitespace();
    }

    private static ParameterSyntax CreateParameter(PropertyInfo propertyInfo)
    {
        return SyntaxFactory.Parameter(SyntaxFactory.Identifier(propertyInfo.Name))
            .WithType(propertyInfo.Type);
    }

    private static ParameterListSyntax CreateParameterList(IEnumerable<PropertyInfo> propertyInfos)
    {
        var parameters = SyntaxFactory.ParameterList();
        foreach (var propertyInfo in propertyInfos)
        {
            parameters = parameters.AddParameters(CreateParameter(propertyInfo));
        }
        return parameters;
    }

    private static RecordDeclarationSyntax CreateRecord(RecordOrClassInfo recordOrClassInfo)
    {
        var propertiesAsString = string.Join(",", recordOrClassInfo.Properties.Select(p => p.Text));

        var constructorInfo = ConstructorInfo.Create(recordOrClassInfo.Name, recordOrClassInfo.Properties);

        var constructor = CreateConstructor(constructorInfo);

        var factoryMethod = CreateFactoryMethod(constructorInfo);

        var res = SyntaxFactory.RecordDeclaration(
                SyntaxKind.RecordDeclaration,
                SyntaxFactory.Token(SyntaxKind.RecordKeyword),
                SyntaxFactory.Identifier(recordOrClassInfo.Name))
            .WithModifiers(SyntaxTokenList.Create(
                SyntaxFactory.Token(SyntaxKind.PartialKeyword)
            ))
            .WithLeadingTrivia(CreateSingleLineComment($"Properties: {propertiesAsString}"))
            .WithOpenBraceToken(SyntaxFactory.Token(SyntaxKind.OpenBraceToken))
            .WithCloseBraceToken(SyntaxFactory.Token(SyntaxKind.CloseBraceToken))
            .AddMembers(constructor, factoryMethod);
        return res;
    }

    private static SyntaxTriviaList CreateSingleLineComment(string comment)
    {
        // Future: Here is how to write xml comment. https://stackoverflow.com/questions/30695752/how-do-i-add-an-xml-doc-comment-to-a-classdeclarationsyntax-in-roslyn
        return SyntaxTriviaList.Create(SyntaxFactory.SyntaxTrivia(SyntaxKind.SingleLineCommentTrivia, "// "+ comment));
    }

    /// <summary> Copied with pride from https://andrewlock.net/creating-a-source-generator-part-5-finding-a-type-declarations-namespace-and-type-hierarch/
    // determine the namespace the class/enum/struct is declared in, if any
    private static string GetNamespaceName(BaseTypeDeclarationSyntax syntax)
    {
        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        string nameSpace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        SyntaxNode? potentialNamespaceParent = syntax.Parent;

        // Keep moving "out" of nested classes etc until we get to a namespace
        // or until we run out of parents
        while (potentialNamespaceParent != null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax
               && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            nameSpace = namespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                namespaceParent = parent;
            }
        }

        // return the final namespace
        return nameSpace;
    }
}